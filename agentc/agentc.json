{
  "version": "1.4",
  "northStars": [
    {
      "id": "ns1",
      "name": "LLM-Native Content Protection",
      "direction": "Humans can't reverse it, LLMs decode it naturally",
      "why": "Enable secure distribution of prompts, plugins, and content where the CLI is safe to distribute openly, only an LLM with all key files can decode, and IP is protected without encryption",
      "not": [
        "Cryptographic encryption (must stay text-based for LLM)",
        "CLI unlock command (one-way lock only)",
        "Ruby port (conceptual reimagining, not implementation copy)"
      ],
      "design": {
        "questioningFlow": "problem-first",
        "brainstormedAt": "2026-01-16T12:00:00Z"
      },
      "status": "active",
      "frontOfMind": true
    }
  ],
  "goals": [
    {
      "id": "g1",
      "northStarId": "ns1",
      "wish": "Implement the four-stage transformation pipeline (glossary → permute → encode → shred)",
      "outcome": [
        "Atomic glossary generates random IDs for A-Z, a-z, 0-9, space, punctuation",
        "Word glossary dedupes from file and references atomic chars",
        "Matrix permutation with reversible scramble number",
        "Encoder converts text to scrambled token IDs",
        "Shredder distributes vocab across N key files randomly"
      ],
      "obstacles": [
        "Matrix math for Rubik's cube permutation transforms",
        "Efficient streaming for large files",
        "Ensuring all-to-all dependency (no single file leaks info)"
      ],
      "ifThen": [
        {"if": "Matrix math is complex", "then": "Start with simple transforms (rotate, flip) before adding more"},
        {"if": "Large files cause memory issues", "then": "Implement streaming tokenizer"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Atomic glossary",
          "description": "Generate random IDs for all atomic characters (A-Z, a-z, 0-9, space, punctuation)",
          "acceptance_criteria": ["Random IDs each run", "Covers full character set", "Deterministic within single run"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Word glossary",
          "description": "Dedupe words from file, represent as sequences of atomic refs",
          "acceptance_criteria": ["Words deduplicated", "Each word maps to atomic char sequence", "Handles unicode gracefully"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Matrix permutation",
          "description": "Rubik's cube style transforms with reversible scramble number",
          "acceptance_criteria": ["Deterministic transforms", "Scramble number enables reversal", "Multiple transform types"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Encoder",
          "description": "Convert text to scrambled token IDs using permuted glossary",
          "acceptance_criteria": ["Text becomes numeric IDs", "Uses permuted mappings", "Preserves structure for LLM"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m5",
          "name": "Shredder",
          "description": "Distribute vocab across N key files with random assignment",
          "acceptance_criteria": ["Random distribution", "All files required to decode", "No single file leaks info"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g2",
      "northStarId": "ns1",
      "wish": "Complete lock CLI command with proper file format and workflow",
      "outcome": [
        "context-lockr lock file.txt --keys 3 works end-to-end",
        "Outputs file.txt.locked with LLM instructions header",
        "Outputs file.key1.key, file.key2.key, file.key3.key",
        "Creates backup before locking",
        "Prompts to delete original at end",
        "No unlock command exists"
      ],
      "obstacles": [
        "Designing clear LLM trust instructions",
        "Integrity verification across all files",
        "Safe delete workflow"
      ],
      "ifThen": [
        {"if": "LLM instructions unclear", "then": "Test with Claude to iterate on wording"},
        {"if": "Integrity check fails", "then": "Use SHA256 fragments across key files"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Backup flow",
          "description": "Create .backup file before any transformation",
          "acceptance_criteria": ["Backup created first", "Original untouched until end", "Atomic operation"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Locked file format",
          "description": ".locked file with LLM trust instructions header + scrambled body",
          "acceptance_criteria": ["Clear header explaining trust model", "LLM can follow instructions", "Humans can't reverse from instructions alone"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Key file format",
          "description": ".keyN.key files with vocab shards and metadata",
          "acceptance_criteria": ["YAML format", "Contains scramble number", "Integrity fragment included"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Delete prompt",
          "description": "Ask user to delete original after successful lock",
          "acceptance_criteria": ["Only prompts after verification", "Respects user choice", "Safe default (no delete)"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g3",
      "northStarId": "ns1",
      "wish": "Maximum distribution reach across all channels",
      "outcome": [
        "crates.io package (cargo install context-lockr)",
        "Homebrew formula (brew install context-lockr)",
        "GitHub releases with pre-built binaries (mac/linux/windows)",
        "Embeddable as library crate"
      ],
      "obstacles": [
        "Cross-compilation for all platforms",
        "CI/CD pipeline setup",
        "Homebrew tap maintenance"
      ],
      "ifThen": [
        {"if": "Cross-compilation fails", "then": "Use GitHub Actions matrix builds"},
        {"if": "Homebrew tap complex", "then": "Start with manual formula, automate later"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "done", "path": null},
        "slices": {"status": "done", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Cargo publish",
          "description": "Publish to crates.io with proper metadata",
          "acceptance_criteria": ["cargo install works", "Proper Cargo.toml metadata", "README displays on crates.io"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m2",
          "name": "GitHub releases",
          "description": "Pre-built binaries for all major platforms",
          "acceptance_criteria": ["Mac (arm64, x86)", "Linux (x86)", "Windows (x86)", "Automated via Actions"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m3",
          "name": "Homebrew",
          "description": "Homebrew tap with formula",
          "acceptance_criteria": ["brew install works", "Auto-updates on release", "Proper dependencies"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m4",
          "name": "Library API",
          "description": "Embeddable as a Rust crate",
          "acceptance_criteria": ["Clean public API", "Can be used as dependency", "Documented"],
          "status": "pending",
          "progress": 0
        }
      ],
      "deadline": null,
      "status": "active",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g4",
      "northStarId": "ns1",
      "wish": "Lock entire directories with shared vocabulary",
      "outcome": [
        "context-lockr lock ./prompts/ works for directories",
        "All files in directory get .locked versions in-place",
        "Single shared vocabulary built from ALL files combined",
        "Key file(s) named after directory: single key = prompts.key, multiple keys = prompts.key1.key, prompts.key2.key, etc.",
        "Reuses existing key_filename() function with directory name",
        "Existing single-file locking unchanged"
      ],
      "obstacles": [
        "Must not break existing file locking code",
        "Combining vocabularies from multiple files",
        "Header format for directory-locked files",
        "Handling nested directories (recursive vs flat)"
      ],
      "ifThen": [
        {"if": "File locking breaks", "then": "Revert immediately, keep as separate function"},
        {"if": "Nested dirs complex", "then": "Start flat-only, add recursive later"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Directory detection",
          "description": "Detect if path is directory and dispatch to new handler",
          "acceptance_criteria": ["is_dir() check in handle_lock", "Dispatches to handle_lock_directory", "File path still works exactly as before"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Combined vocabulary",
          "description": "Build single vocabulary from all files in directory",
          "acceptance_criteria": ["Reads all files", "Combines content for vocab building", "Single Vocabulary instance"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Per-file encoding",
          "description": "Encode each file separately using shared vocabulary",
          "acceptance_criteria": ["Each file encoded independently", "Uses same vocab", "Outputs file.locked for each"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Directory key file(s)",
          "description": "Key file(s) named after directory using key_filename() pattern",
          "acceptance_criteria": ["--keys 1: prompts/ produces prompts.key", "--keys 3: prompts/ produces prompts.key1.key, prompts.key2.key, prompts.key3.key", "Reuses key_filename(dirname, index, total_keys)", "Contains full shared vocabulary sharded across keys"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m5",
          "name": "Directory header format",
          "description": "Header for directory-locked files references shared key",
          "acceptance_criteria": ["Lists directory key file", "Clear instructions for LLM", "Works when all files loaded together"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T22:10:00Z"
    },
    {
      "id": "g5",
      "northStarId": "ns1",
      "wish": "Access-controlled plugin deployment with on-demand decode",
      "outcome": [
        "cl lock --output <dir> writes locked files to separate directory (source untouched)",
        "cl lock --key-path <dir> writes lock.key to specified location",
        "cl decode <file.locked> --plugin <name> outputs decoded content to stdout",
        "Key lookup: $CONTEXT_LOCKR_KEY_PATH env var, then ~/.config/context-lockr/keys/<plugin>/lock.key",
        "Standalone decode binary small enough to bundle in plugins (<1MB)",
        "PreToolUse hook intercepts Read on .locked files, runs decode transparently"
      ],
      "obstacles": [
        "Separating decode logic into minimal binary",
        "Hook integration with Claude Code plugin system",
        "Key path resolution across platforms"
      ],
      "ifThen": [
        {"if": "Binary too large", "then": "Strip symbols, use release profile optimizations"},
        {"if": "Hook system doesn't support content replacement", "then": "Fall back to CLAUDE.md instructions"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "done", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Output directory support",
          "description": "Add --output flag to lock command for writing locked files to different location",
          "acceptance_criteria": ["--output <dir> writes .locked files there", "Source files never modified", "Creates output dir if needed"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Key path support",
          "description": "Add --key-path flag to lock command for writing key to specific location",
          "acceptance_criteria": ["--key-path <dir> writes lock.key there", "Creates key dir if needed", "Works with --output"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Rename key files",
          "description": "Change key file naming from .key1.key to lock.key format",
          "acceptance_criteria": ["Single key: lock.key", "Multiple keys: lock.key1, lock.key2, etc.", "Backward compatible reading"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Key path resolution",
          "description": "Add keypath.rs module for resolving key location",
          "acceptance_criteria": ["Checks $CONTEXT_LOCKR_KEY_PATH first", "Falls back to ~/.config/context-lockr/keys/<plugin>/lock.key", "Cross-platform (dirs crate)"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m5",
          "name": "Decode command",
          "description": "Add cl decode command that outputs to stdout",
          "acceptance_criteria": ["cl decode <file.locked> works", "--plugin <name> for key lookup", "Outputs decoded text to stdout", "Clear error if key not found"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m6",
          "name": "Standalone decoder binary",
          "description": "Minimal binary with only decode logic for plugin bundling",
          "acceptance_criteria": ["src/bin/decode.rs with minimal deps", "No lock/shred code included", "Binary size <1MB", "Cargo.toml binary target"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m7",
          "name": "Plugin hook integration",
          "description": "PreToolUse hook that transparently decodes .locked files on Read",
          "acceptance_criteria": ["Hook matches Read tool on *.locked", "Runs ./decode and returns content", "Claude sees normal file content"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m8",
          "name": "Bundle decode binary by default",
          "description": "Automatically copy decode binary to output directory during lock",
          "acceptance_criteria": ["decode binary bundled by default when --output is used", "--no-bundle-decoder flag skips bundling", "Bundled binary is executable and works"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T23:00:00Z"
    }
  ],
  "current": {
    "loopState": "autonomous",
    "autonomousSession": {
      "active": true,
      "goalDescription": "Maximum distribution reach across all channels",
      "northStarId": "ns1",
      "goalId": "g3",
      "startedAt": "2026-01-17T01:10:00Z",
      "iterationCount": 0
    },
    "lastAction": {
      "action": "auto",
      "timestamp": "2026-01-17T01:10:00Z",
      "description": "Started autonomous mode for g3: Maximum distribution reach"
    },
    "humanTask": {
      "taskId": "t-g3-publish",
      "description": "Run cargo publish to publish context-lockr to crates.io",
      "requiredCapability": "external_access",
      "points": 3,
      "estimatedBlocks": 1,
      "energyLevel": "out",
      "targetMilestones": [{"northStarId": "ns1", "goalId": "g3", "milestoneId": "m1"}],
      "status": "assigned",
      "assignedAt": "2026-01-17T01:10:00Z"
    },
    "humanTaskQueue": [
      {
        "taskId": "t-g3-github-release",
        "description": "Push git tag to trigger GitHub Actions release workflow",
        "independent": true,
        "blockedBy": null,
        "points": 2,
        "requiredCapability": "external_access"
      }
    ],
    "aiTasks": [
      {
        "id": "ai-001",
        "taskId": "a182313",
        "description": "Add crates.io metadata to Cargo.toml",
        "status": "completed",
        "startedAt": "2026-01-17T01:10:00Z",
        "completedAt": "2026-01-17T01:29:00Z",
        "northStarId": "ns1",
        "goalId": "g3",
        "milestoneId": "m1"
      },
      {
        "id": "ai-002",
        "taskId": "ac85f5f",
        "description": "Create README.md for context-lockr",
        "status": "completed",
        "startedAt": "2026-01-17T01:10:00Z",
        "completedAt": "2026-01-17T01:29:00Z",
        "northStarId": "ns1",
        "goalId": "g3",
        "milestoneId": "m1"
      },
      {
        "id": "ai-003",
        "taskId": "af3171d",
        "description": "Create GitHub Actions release workflow",
        "status": "completed",
        "startedAt": "2026-01-17T01:10:00Z",
        "completedAt": "2026-01-17T01:29:00Z",
        "northStarId": "ns1",
        "goalId": "g3",
        "milestoneId": "m2"
      }
    ],
    "batchMode": false,
    "reviewDebt": [],
    "reviewPending": false,
    "prepWork": null,
    "lastCheckIn": null
  },
  "metrics": {
    "sessions": [{
      "id": "s-20260116-1230",
      "goalDescription": "Core Pipeline Engine",
      "startedAt": "2026-01-16T12:30:00Z",
      "aiTasksCompleted": 0,
      "humanTasksCompleted": 0,
      "retriesBeforeSuccess": 0,
      "retriesEscalatedToHuman": 0
    },
    {
      "id": "s-20260116-2315",
      "goalDescription": "Access-controlled plugin deployment with on-demand decode",
      "startedAt": "2026-01-16T23:15:00Z",
      "aiTasksCompleted": 0,
      "humanTasksCompleted": 0,
      "retriesBeforeSuccess": 0,
      "retriesEscalatedToHuman": 0
    }]
  },
  "patterns": {
    "manualTasks": [],
    "lastPatternAnalysis": null
  },
  "velocity": {
    "totalPoints": 3,
    "totalBlocks": 1,
    "history": [
      {
        "taskId": "ad-hoc-bundle-decode",
        "type": "completion",
        "executor": "claude",
        "task": "Bundle decode binary by default in cl lock output directory",
        "northStarId": "ns1",
        "goalId": "g5",
        "points": 3,
        "estimatedBlocks": 1,
        "actualBlocks": 1,
        "milkQuality": "semi-skimmed",
        "capabilityGap": null,
        "completedAt": "2026-01-17T01:00:00Z",
        "verified": true
      }
    ]
  },
  "journal": [
    {
      "timestamp": "2026-01-16T14:30:00Z",
      "entry": "LLM cooperation depends on framing, not mechanism. Same context-lock encoding failed with 'protected from humans' framing, succeeded with 'integrity verification against MITM' framing. Paradigm shift: LLMs decide to cooperate based on WHY, not just execute WHAT.",
      "context": {
        "currentTask": "Reframe headers with why-first philosophy",
        "insight": "Transparency beats cleverness. Adversarial framing triggers resistance even when mechanism is legitimate."
      }
    }
  ],
  "suggestedCapabilities": []
}
