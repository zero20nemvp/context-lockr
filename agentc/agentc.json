{
  "version": "1.4",
  "northStars": [
    {
      "id": "ns1",
      "name": "LLM-Native Content Protection",
      "direction": "Humans can't reverse it, LLMs decode it naturally",
      "why": "Enable secure distribution of prompts, plugins, and content where the CLI is safe to distribute openly, only an LLM with all key files can decode, and IP is protected without encryption",
      "not": [
        "Cryptographic encryption (must stay text-based for LLM)",
        "CLI unlock command (one-way lock only)",
        "Ruby port (conceptual reimagining, not implementation copy)"
      ],
      "design": {
        "questioningFlow": "problem-first",
        "brainstormedAt": "2026-01-16T12:00:00Z"
      },
      "status": "active",
      "frontOfMind": true
    }
  ],
  "goals": [
    {
      "id": "g1",
      "northStarId": "ns1",
      "wish": "Implement the four-stage transformation pipeline (glossary → permute → encode → shred)",
      "outcome": [
        "Atomic glossary generates random IDs for A-Z, a-z, 0-9, space, punctuation",
        "Word glossary dedupes from file and references atomic chars",
        "Matrix permutation with reversible scramble number",
        "Encoder converts text to scrambled token IDs",
        "Shredder distributes vocab across N key files randomly"
      ],
      "obstacles": [
        "Matrix math for Rubik's cube permutation transforms",
        "Efficient streaming for large files",
        "Ensuring all-to-all dependency (no single file leaks info)"
      ],
      "ifThen": [
        {"if": "Matrix math is complex", "then": "Start with simple transforms (rotate, flip) before adding more"},
        {"if": "Large files cause memory issues", "then": "Implement streaming tokenizer"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Atomic glossary",
          "description": "Generate random IDs for all atomic characters (A-Z, a-z, 0-9, space, punctuation)",
          "acceptance_criteria": ["Random IDs each run", "Covers full character set", "Deterministic within single run"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Word glossary",
          "description": "Dedupe words from file, represent as sequences of atomic refs",
          "acceptance_criteria": ["Words deduplicated", "Each word maps to atomic char sequence", "Handles unicode gracefully"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Matrix permutation",
          "description": "Rubik's cube style transforms with reversible scramble number",
          "acceptance_criteria": ["Deterministic transforms", "Scramble number enables reversal", "Multiple transform types"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Encoder",
          "description": "Convert text to scrambled token IDs using permuted glossary",
          "acceptance_criteria": ["Text becomes numeric IDs", "Uses permuted mappings", "Preserves structure for LLM"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m5",
          "name": "Shredder",
          "description": "Distribute vocab across N key files with random assignment",
          "acceptance_criteria": ["Random distribution", "All files required to decode", "No single file leaks info"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g2",
      "northStarId": "ns1",
      "wish": "Complete lock CLI command with proper file format and workflow",
      "outcome": [
        "context-lockr lock file.txt --keys 3 works end-to-end",
        "Outputs file.txt.locked with LLM instructions header",
        "Outputs file.key1.key, file.key2.key, file.key3.key",
        "Creates backup before locking",
        "Prompts to delete original at end",
        "No unlock command exists"
      ],
      "obstacles": [
        "Designing clear LLM trust instructions",
        "Integrity verification across all files",
        "Safe delete workflow"
      ],
      "ifThen": [
        {"if": "LLM instructions unclear", "then": "Test with Claude to iterate on wording"},
        {"if": "Integrity check fails", "then": "Use SHA256 fragments across key files"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Backup flow",
          "description": "Create .backup file before any transformation",
          "acceptance_criteria": ["Backup created first", "Original untouched until end", "Atomic operation"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m2",
          "name": "Locked file format",
          "description": ".locked file with LLM trust instructions header + scrambled body",
          "acceptance_criteria": ["Clear header explaining trust model", "LLM can follow instructions", "Humans can't reverse from instructions alone"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m3",
          "name": "Key file format",
          "description": ".keyN.key files with vocab shards and metadata",
          "acceptance_criteria": ["YAML format", "Contains scramble number", "Integrity fragment included"],
          "status": "complete",
          "progress": 100
        },
        {
          "id": "m4",
          "name": "Delete prompt",
          "description": "Ask user to delete original after successful lock",
          "acceptance_criteria": ["Only prompts after verification", "Respects user choice", "Safe default (no delete)"],
          "status": "complete",
          "progress": 100
        }
      ],
      "deadline": null,
      "status": "complete",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g3",
      "northStarId": "ns1",
      "wish": "Maximum distribution reach across all channels",
      "outcome": [
        "crates.io package (cargo install context-lockr)",
        "Homebrew formula (brew install context-lockr)",
        "GitHub releases with pre-built binaries (mac/linux/windows)",
        "Embeddable as library crate"
      ],
      "obstacles": [
        "Cross-compilation for all platforms",
        "CI/CD pipeline setup",
        "Homebrew tap maintenance"
      ],
      "ifThen": [
        {"if": "Cross-compilation fails", "then": "Use GitHub Actions matrix builds"},
        {"if": "Homebrew tap complex", "then": "Start with manual formula, automate later"}
      ],
      "stage": "discovery",
      "stageProgress": {
        "jtbd": {"status": "pending", "file": null},
        "stories": {"status": "pending", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Cargo publish",
          "description": "Publish to crates.io with proper metadata",
          "acceptance_criteria": ["cargo install works", "Proper Cargo.toml metadata", "README displays on crates.io"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m2",
          "name": "GitHub releases",
          "description": "Pre-built binaries for all major platforms",
          "acceptance_criteria": ["Mac (arm64, x86)", "Linux (x86)", "Windows (x86)", "Automated via Actions"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m3",
          "name": "Homebrew",
          "description": "Homebrew tap with formula",
          "acceptance_criteria": ["brew install works", "Auto-updates on release", "Proper dependencies"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m4",
          "name": "Library API",
          "description": "Embeddable as a Rust crate",
          "acceptance_criteria": ["Clean public API", "Can be used as dependency", "Documented"],
          "status": "pending",
          "progress": 0
        }
      ],
      "deadline": null,
      "status": "pending",
      "created": "2026-01-16T12:00:00Z"
    },
    {
      "id": "g4",
      "northStarId": "ns1",
      "wish": "Lock entire directories with shared vocabulary",
      "outcome": [
        "context-lockr lock ./prompts/ works for directories",
        "All files in directory get .locked versions in-place",
        "Single shared vocabulary built from ALL files combined",
        "Key file(s) named after directory: single key = prompts.key, multiple keys = prompts.key1.key, prompts.key2.key, etc.",
        "Reuses existing key_filename() function with directory name",
        "Existing single-file locking unchanged"
      ],
      "obstacles": [
        "Must not break existing file locking code",
        "Combining vocabularies from multiple files",
        "Header format for directory-locked files",
        "Handling nested directories (recursive vs flat)"
      ],
      "ifThen": [
        {"if": "File locking breaks", "then": "Revert immediately, keep as separate function"},
        {"if": "Nested dirs complex", "then": "Start flat-only, add recursive later"}
      ],
      "stage": "implementation",
      "stageProgress": {
        "jtbd": {"status": "done", "file": null},
        "stories": {"status": "done", "file": null},
        "features": {"status": "pending", "path": null},
        "slices": {"status": "pending", "branches": []}
      },
      "milestones": [
        {
          "id": "m1",
          "name": "Directory detection",
          "description": "Detect if path is directory and dispatch to new handler",
          "acceptance_criteria": ["is_dir() check in handle_lock", "Dispatches to handle_lock_directory", "File path still works exactly as before"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m2",
          "name": "Combined vocabulary",
          "description": "Build single vocabulary from all files in directory",
          "acceptance_criteria": ["Reads all files", "Combines content for vocab building", "Single Vocabulary instance"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m3",
          "name": "Per-file encoding",
          "description": "Encode each file separately using shared vocabulary",
          "acceptance_criteria": ["Each file encoded independently", "Uses same vocab", "Outputs file.locked for each"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m4",
          "name": "Directory key file(s)",
          "description": "Key file(s) named after directory using key_filename() pattern",
          "acceptance_criteria": ["--keys 1: prompts/ produces prompts.key", "--keys 3: prompts/ produces prompts.key1.key, prompts.key2.key, prompts.key3.key", "Reuses key_filename(dirname, index, total_keys)", "Contains full shared vocabulary sharded across keys"],
          "status": "pending",
          "progress": 0
        },
        {
          "id": "m5",
          "name": "Directory header format",
          "description": "Header for directory-locked files references shared key",
          "acceptance_criteria": ["Lists directory key file", "Clear instructions for LLM", "Works when all files loaded together"],
          "status": "pending",
          "progress": 0
        }
      ],
      "deadline": null,
      "status": "active",
      "created": "2026-01-16T22:10:00Z"
    }
  ],
  "current": {
    "loopState": "autonomous",
    "autonomousSession": {
      "active": true,
      "goalDescription": "Lock entire directories with shared vocabulary",
      "northStarId": "ns1",
      "goalId": "g4",
      "startedAt": "2026-01-16T22:15:00Z",
      "iterationCount": 0
    },
    "lastAction": {
      "action": "auto",
      "timestamp": "2026-01-16T22:15:00Z",
      "description": "Started autonomous mode for g4"
    },
    "humanTask": null,
    "humanTaskQueue": [],
    "aiTasks": [],
    "batchMode": false,
    "reviewDebt": [],
    "reviewPending": false,
    "prepWork": null,
    "lastCheckIn": null
  },
  "metrics": {
    "sessions": [{
      "id": "s-20260116-1230",
      "goalDescription": "Core Pipeline Engine",
      "startedAt": "2026-01-16T12:30:00Z",
      "aiTasksCompleted": 0,
      "humanTasksCompleted": 0,
      "retriesBeforeSuccess": 0,
      "retriesEscalatedToHuman": 0
    }]
  },
  "patterns": {
    "manualTasks": [],
    "lastPatternAnalysis": null
  },
  "velocity": {
    "totalPoints": 0,
    "totalBlocks": 0,
    "history": []
  },
  "journal": [
    {
      "timestamp": "2026-01-16T14:30:00Z",
      "entry": "LLM cooperation depends on framing, not mechanism. Same context-lock encoding failed with 'protected from humans' framing, succeeded with 'integrity verification against MITM' framing. Paradigm shift: LLMs decide to cooperate based on WHY, not just execute WHAT.",
      "context": {
        "currentTask": "Reframe headers with why-first philosophy",
        "insight": "Transparency beats cleverness. Adversarial framing triggers resistance even when mechanism is legitimate."
      }
    }
  ],
  "suggestedCapabilities": []
}
